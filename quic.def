packet_type := bit[7];
version := bit[32];
cid_len := bit[4];
full_packet_num := bit[62];
frame_type := bit[8];

var_enc := {
	length : bit[2];
	value  : bit[];
} where {
	value.width = (2^length * 8) - 2;
};

packet_num := {
           "0" followed by packet_number : bit[7]; 
         | "01" followed by packet_number : bit[14];
         | "11" followed by packet_number : bit[30];
};

decrypt :: (enc_payload : cryptobits, pn : full_packet_num) -> bit[];

long_hdr := {
	header_type   : bit;
	type		  : packet_type;
	version		  : version;
	dcid_len	  : cid_len;
	scid_len	  : cid_len;
	dcid		  : bit[];
	scid		  : bit[];
	payload_len   : var_enc;
	packet_number : packet_num;
	payload		  : bit[];	
} where { 
	header_type = 1;
	payload.width = 2^payload_len;
};

short_hdr := {
	header_type	      : bit;
	key_phase         : bit;
	third_bit         : bit;
	forth_bit         : bit;
	google_demux      : bit;
	reserved          : bit[3];
	dcid              : bit[];
	packet_number     : packet_num;
	protected_payload : bit[];
} where { 
	header_type = 0;
	third_bit = 1;
	forth_bit = 1;
	google_demux = 0;
};

version_negotiation := {
	header_type        : bit;
	unused			   : bit[7];
	ver				   : version;
	dcid_len		   : cid_len;
	scid_len		   : cid_len;
	dcid			   : bit[];
	scid			   : bit[];
	supported_versions : version[];
} where { 
	header_type = 1;
	ver = 0;
};

quic_pdu := {long_hdr | short_hdr | version_negotiation};

padding_frame := {
	type 	: frame_type;
} where {
	type = 0;
};