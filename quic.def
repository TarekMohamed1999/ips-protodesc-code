packet_type := bit[7];
version := bit[32];
cid_len := bit[4];
full_packet_num := bit[62];
frame_type := bit[8];

var_enc := {
	length : bit[2];
	value  : bit[];
} where {
	value.length == (length*length * 8) - 2;
};

packet_num := {
           "0" followed by packet_number : bit[7]; 
         | "01" followed by packet_number : bit[14];
         | "11" followed by packet_number : bit[30];
};

decrypt :: (enc_payload : cryptobits, pn : full_packet_num) -> bit[];

long_hdr := {
	header_type   : bit;
	type		  : packet_type;
	version		  : version;
	dcid_len	  : cid_len;
	scid_len	  : cid_len;
	dcid		  : bit[];
	scid		  : bit[];
	payload_len   : var_enc;
	packet_number : packet_num;
	payload		  : bit[];	
} where { 
	header_type == 1;
	dcid.length == ((dcid_len == 0) ? 0 : (dcid_len+3) * 8);
	scid.length == ((scid_len == 0) ? 0 : (scid_len+3) * 8);
	payload.length == payload_len*payload_len;
};

short_hdr := {
	header_type	      : bit;
	key_phase         : bit;
	third_bit         : bit;
	forth_bit         : bit;
	google_demux      : bit;
	reserved          : bit[3];
	dcid              : bit[];
	packet_number     : packet_num;
	protected_payload : bit[];
} where { 
	header_type == 0;
	third_bit == 1;
	forth_bit == 1;
	google_demux == 0;
};

version_negotiation := {
	header_type        : bit;
	unused			   : bit[7];
	ver				   : version;
	dcid_len		   : cid_len;
	scid_len		   : cid_len;
	dcid			   : bit[];
	scid			   : bit[];
	supported_versions : version[];
} where { 
	header_type == 1;
	ver == 0;
	dcid.length == ((dcid_len == 0) ? 0 : (dcid_len+3) * 8);
	scid.length == ((scid_len == 0) ? 0 : (scid_len+3) * 8);
};

padding_frame := {
	type 	: frame_type;
} where {
	type == 0;
};

pdus := {long_hdr | short_hdr | version_negotiation};