# Generic helpers

letter      = anything:x ?(x in ascii_letters)
punc        = anything:x ?(x in punctuation)
digit       = anything:x ?(x in '0123456789')
letterdigit = letter|digit
word        = <(letter|punc|number)+>:ls -> str(ls)
alphanum    = <(letter|number)+>:ls -> str(ls)
wordnum     = <(letter|number|punc)+>:ls -> str(ls)

uppercase_letter = anything:x ?(x in ascii_uppercase) -> x
lowercase_letter = anything:x ?(x in ascii_lowercase) -> x
number           = <digit+>:ds -> int(ds)

capitalised_word = uppercase_letter:l <(lowercase_letter|punc)*>:ls -> str(l + ls)

pdu_name = <(word:w ?(w != "is")' '?)*>:name -> str(name)[:-1]


# expressions redo
parens = '(' ws equality_expr:e ws ')' -> e
value  = number:n -> new_constant("Number", n)
       | parens
       | field_name:name -> new_fieldaccess(new_this(), name)

eq  = '==' ws bool_expr:n -> ('==', n)
neq = '!=' ws bool_expr:n -> ('==', n)

and = ('&&'| ws 'and') ws ord_expr:n -> ('&&', n)
or  = ('||'| ws 'or')  ws ord_expr:n -> ('||', n)
not = ('!'| ws 'not')  ws ord_expr:n -> ('!',  n)

leq = '<=' ws addsub_expr:n -> ('<=', n)
lt  = '<'  ws addsub_expr:n -> ('<',  n)
geq = '>=' ws addsub_expr:n -> ('>=', n)
gt  = '>'  ws addsub_expr:n -> ('>',  n)

add = '+' ws muldiv_expr:n -> ('+', n)
sub = '-' ws muldiv_expr:n -> ('-', n)
mul = '*' ws value:n -> ('*', n)
div = '/' ws value:n -> ('/', n)
mod = '%' ws value:n -> ('%', n)

equality = (eq | neq)
boolean  = (and | or | not)
ordinal  = (leq | lt | geq | gt)
addsub   = (add | sub)
muldiv   = (mul | div | mod)

equality_expr = bool_expr:left   equality*:rights -> build_tree(left, rights, "")
bool_expr     = ord_expr:left    boolean*:rights  -> build_tree(left, rights, "")
ord_expr      = addsub_expr:left ordinal*:rights  -> build_tree(left, rights, "")
addsub_expr   = muldiv_expr:left addsub*:rights   -> build_tree(left, rights, "")
muldiv_expr   = value:left       muldiv*:rights   -> build_tree(left, rights, "")

field_name = <(alphanum:w ' '?)*>:name -> name.strip()

short_field_name = alphanum:name -> name.strip()

field_title = field_name:full_label ('(' short_field_name:short_label ')' -> short_label)?:short_label (('.' -> (full_label, short_label, generate_bitstring_type(protocol, full_label, None, None))) | ': ' equality_expr:size (' ' ('bits'|'bytes'|'bit'|'byte'))?:units ('; present only when ' equality_expr:cond)? '.' -> (full_label, short_label, generate_bitstring_type(protocol, full_label, size, units)))

# Preamble

preamble = <(word:w ?(w != "An" and w != "A")' '?)+>? ("An "|"A ") pdu_name:name "is formatted as follows:" -> name

# Diagram

separator_line = ('|'|'..') ws '+-'+ '+'? <(anything:x ?(x != "|" and x != '.'))*>:ls -> None
diagram_field_var = ('|'|'..') <(anything:x ?(x != "|" and x != '.'))*>:ls '.' -> ("var", str(ls).strip())
diagram_field = ('|'|'..') <(anything:x ?(x != "|" and x != '.'))*>:ls -> (int((len(str(ls))+1)/2), str(ls).strip())
diagram = <(anything:x ?(x != "|" and x != '.'))*> (separator_line|diagram_field_var|diagram_field)+:fields <(anything:x ?(x != "|" and x != '.'))*> -> proc_diagram_fields(fields)
