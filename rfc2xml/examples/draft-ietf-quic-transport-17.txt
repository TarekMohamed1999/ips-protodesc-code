



QUIC                                                     J. Iyengar, Ed.
Internet-Draft                                                    Fastly
Intended status: Standards Track                         M. Thomson, Ed.
Expires: June 21, 2019                                           Mozilla
                                                       December 18, 2018


           QUIC: A UDP-Based Multiplexed and Secure Transport
                      draft-ietf-quic-transport-17

Abstract

   This document defines the core of the QUIC transport protocol.
   Accompanying documents describe QUIC's loss detection and congestion
   control [QUIC-RECOVERY] and the use of TLS for key negotiation
   [QUIC-TLS].

Note to Readers

   Discussion of this draft takes place on the QUIC working group
   mailing list (quic@ietf.org), which is archived at
   <https://mailarchive.ietf.org/arch/search/?email_list=quic>.

   Working Group information can be found at <https://github.com/
   quicwg>; source code and issues list for this draft can be found at
   <https://github.com/quicwg/base-drafts/labels/-transport>.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on June 21, 2019.








Iyengar & Thomson         Expires June 21, 2019                 [Page 1]

Internet-Draft           QUIC Transport Protocol           December 2018


Copyright Notice

   Copyright (c) 2018 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (https://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   5
     1.1.  Document Structure  . . . . . . . . . . . . . . . . . . .   6
     1.2.  Terms and Definitions . . . . . . . . . . . . . . . . . .   7
     1.3.  Notational Conventions  . . . . . . . . . . . . . . . . .   8
   2.  Streams . . . . . . . . . . . . . . . . . . . . . . . . . . .   8
     2.1.  Stream Types and Identifiers  . . . . . . . . . . . . . .   9
     2.2.  Sending and Receiving Data  . . . . . . . . . . . . . . .  10
     2.3.  Stream Prioritization . . . . . . . . . . . . . . . . . .  10
   3.  Stream States . . . . . . . . . . . . . . . . . . . . . . . .  11
     3.1.  Send Stream States  . . . . . . . . . . . . . . . . . . .  11
     3.2.  Receive Stream States . . . . . . . . . . . . . . . . . .  13
     3.3.  Permitted Frame Types . . . . . . . . . . . . . . . . . .  16
     3.4.  Bidirectional Stream States . . . . . . . . . . . . . . .  16
     3.5.  Solicited State Transitions . . . . . . . . . . . . . . .  17
   4.  Flow Control  . . . . . . . . . . . . . . . . . . . . . . . .  18
     4.1.  Data Flow Control . . . . . . . . . . . . . . . . . . . .  19
     4.2.  Flow Credit Increments  . . . . . . . . . . . . . . . . .  20
     4.3.  Handling Stream Cancellation  . . . . . . . . . . . . . .  21
     4.4.  Stream Final Offset . . . . . . . . . . . . . . . . . . .  21
     4.5.  Controlling Concurrency . . . . . . . . . . . . . . . . .  22
   5.  Connections . . . . . . . . . . . . . . . . . . . . . . . . .  23
     5.1.  Connection ID . . . . . . . . . . . . . . . . . . . . . .  23
       5.1.1.  Issuing Connection IDs  . . . . . . . . . . . . . . .  24
       5.1.2.  Consuming and Retiring Connection IDs . . . . . . . .  25
     5.2.  Matching Packets to Connections . . . . . . . . . . . . .  25
       5.2.1.  Client Packet Handling  . . . . . . . . . . . . . . .  26
       5.2.2.  Server Packet Handling  . . . . . . . . . . . . . . .  26
     5.3.  Life of a QUIC Connection . . . . . . . . . . . . . . . .  27
   6.  Version Negotiation . . . . . . . . . . . . . . . . . . . . .  27
     6.1.  Sending Version Negotiation Packets . . . . . . . . . . .  28
     6.2.  Handling Version Negotiation Packets  . . . . . . . . . .  28



Iyengar & Thomson         Expires June 21, 2019                 [Page 2]

Internet-Draft           QUIC Transport Protocol           December 2018


     6.3.  Using Reserved Versions . . . . . . . . . . . . . . . . .  29
   7.  Cryptographic and Transport Handshake . . . . . . . . . . . .  29
     7.1.  Example Handshake Flows . . . . . . . . . . . . . . . . .  30
     7.2.  Negotiating Connection IDs  . . . . . . . . . . . . . . .  32
     7.3.  Transport Parameters  . . . . . . . . . . . . . . . . . .  33
       7.3.1.  Values of Transport Parameters for 0-RTT  . . . . . .  34
       7.3.2.  New Transport Parameters  . . . . . . . . . . . . . .  35
       7.3.3.  Version Negotiation Validation  . . . . . . . . . . .  35
   8.  Address Validation  . . . . . . . . . . . . . . . . . . . . .  37
     8.1.  Address Validation During Connection Establishment  . . .  37
       8.1.1.  Address Validation using Retry Packets  . . . . . . .  38
       8.1.2.  Address Validation for Future Connections . . . . . .  38
       8.1.3.  Address Validation Token Integrity  . . . . . . . . .  40
     8.2.  Path Validation . . . . . . . . . . . . . . . . . . . . .  41
     8.3.  Initiating Path Validation  . . . . . . . . . . . . . . .  41
     8.4.  Path Validation Responses . . . . . . . . . . . . . . . .  42
     8.5.  Successful Path Validation  . . . . . . . . . . . . . . .  42
     8.6.  Failed Path Validation  . . . . . . . . . . . . . . . . .  43
   9.  Connection Migration  . . . . . . . . . . . . . . . . . . . .  43
     9.1.  Probing a New Path  . . . . . . . . . . . . . . . . . . .  44
     9.2.  Initiating Connection Migration . . . . . . . . . . . . .  44
     9.3.  Responding to Connection Migration  . . . . . . . . . . .  45
       9.3.1.  Peer Address Spoofing . . . . . . . . . . . . . . . .  45
       9.3.2.  On-Path Address Spoofing  . . . . . . . . . . . . . .  46
       9.3.3.  Off-Path Packet Forwarding  . . . . . . . . . . . . .  47
     9.4.  Loss Detection and Congestion Control . . . . . . . . . .  48
     9.5.  Privacy Implications of Connection Migration  . . . . . .  49
     9.6.  Server's Preferred Address  . . . . . . . . . . . . . . .  50
       9.6.1.  Communicating A Preferred Address . . . . . . . . . .  50
       9.6.2.  Responding to Connection Migration  . . . . . . . . .  50
       9.6.3.  Interaction of Client Migration and Preferred Address  51
   10. Connection Termination  . . . . . . . . . . . . . . . . . . .  51
     10.1.  Closing and Draining Connection States . . . . . . . . .  51
     10.2.  Idle Timeout . . . . . . . . . . . . . . . . . . . . . .  53
     10.3.  Immediate Close  . . . . . . . . . . . . . . . . . . . .  53
     10.4.  Stateless Reset  . . . . . . . . . . . . . . . . . . . .  55
       10.4.1.  Detecting a Stateless Reset  . . . . . . . . . . . .  57
       10.4.2.  Calculating a Stateless Reset Token  . . . . . . . .  57
       10.4.3.  Looping  . . . . . . . . . . . . . . . . . . . . . .  58
   11. Error Handling  . . . . . . . . . . . . . . . . . . . . . . .  59
     11.1.  Connection Errors  . . . . . . . . . . . . . . . . . . .  59
     11.2.  Stream Errors  . . . . . . . . . . . . . . . . . . . . .  60
   12. Packets and Frames  . . . . . . . . . . . . . . . . . . . . .  60
     12.1.  Protected Packets  . . . . . . . . . . . . . . . . . . .  60
     12.2.  Coalescing Packets . . . . . . . . . . . . . . . . . . .  61
     12.3.  Packet Numbers . . . . . . . . . . . . . . . . . . . . .  62
     12.4.  Frames and Frame Types . . . . . . . . . . . . . . . . .  63
   13. Packetization and Reliability . . . . . . . . . . . . . . . .  66



Iyengar & Thomson         Expires June 21, 2019                 [Page 3]

Internet-Draft           QUIC Transport Protocol           December 2018


     13.1.  Packet Processing and Acknowledgment . . . . . . . . . .  66
       13.1.1.  Sending ACK Frames . . . . . . . . . . . . . . . . .  67
       13.1.2.  ACK Frames and Packet Protection . . . . . . . . . .  68
     13.2.  Retransmission of Information  . . . . . . . . . . . . .  68
     13.3.  Explicit Congestion Notification . . . . . . . . . . . .  70
       13.3.1.  ECN Counts . . . . . . . . . . . . . . . . . . . . .  71
       13.3.2.  ECN Verification . . . . . . . . . . . . . . . . . .  71
   14. Packet Size . . . . . . . . . . . . . . . . . . . . . . . . .  73
     14.1.  Path Maximum Transmission Unit (PMTU)  . . . . . . . . .  73
     14.2.  ICMP Packet Too Big Messages . . . . . . . . . . . . . .  74
     14.3.  Datagram Packetization Layer PMTU Discovery  . . . . . .  75
   15. Versions  . . . . . . . . . . . . . . . . . . . . . . . . . .  76
   16. Variable-Length Integer Encoding  . . . . . . . . . . . . . .  77
   17. Packet Formats  . . . . . . . . . . . . . . . . . . . . . . .  77
     17.1.  Packet Number Encoding and Decoding  . . . . . . . . . .  78
     17.2.  Long Header Packet . . . . . . . . . . . . . . . . . . .  79
     17.3.  Short Header Packet  . . . . . . . . . . . . . . . . . .  81
     17.4.  Version Negotiation Packet . . . . . . . . . . . . . . .  83
     17.5.  Initial Packet . . . . . . . . . . . . . . . . . . . . .  84
       17.5.1.  Abandoning Initial Packets . . . . . . . . . . . . .  86
       17.5.2.  Starting Packet Numbers  . . . . . . . . . . . . . .  86
       17.5.3.  0-RTT Packet Numbers . . . . . . . . . . . . . . . .  86
     17.6.  Handshake Packet . . . . . . . . . . . . . . . . . . . .  87
     17.7.  Retry Packet . . . . . . . . . . . . . . . . . . . . . .  88
   18. Transport Parameter Encoding  . . . . . . . . . . . . . . . .  90
     18.1.  Transport Parameter Definitions  . . . . . . . . . . . .  92
   19. Frame Types and Formats . . . . . . . . . . . . . . . . . . .  94
     19.1.  PADDING Frame  . . . . . . . . . . . . . . . . . . . . .  95
     19.2.  PING Frame . . . . . . . . . . . . . . . . . . . . . . .  95
     19.3.  ACK Frames . . . . . . . . . . . . . . . . . . . . . . .  95
       19.3.1.  ACK Block Section  . . . . . . . . . . . . . . . . .  97
       19.3.2.  ECN section  . . . . . . . . . . . . . . . . . . . .  99
     19.4.  RESET_STREAM Frame . . . . . . . . . . . . . . . . . . . 100
     19.5.  STOP_SENDING Frame . . . . . . . . . . . . . . . . . . . 100
     19.6.  CRYPTO Frame . . . . . . . . . . . . . . . . . . . . . . 101
     19.7.  NEW_TOKEN Frame  . . . . . . . . . . . . . . . . . . . . 102
     19.8.  STREAM Frames  . . . . . . . . . . . . . . . . . . . . . 102
     19.9.  MAX_DATA Frame . . . . . . . . . . . . . . . . . . . . . 104
     19.10. MAX_STREAM_DATA Frame  . . . . . . . . . . . . . . . . . 104
     19.11. MAX_STREAMS Frames . . . . . . . . . . . . . . . . . . . 105
     19.12. DATA_BLOCKED Frame . . . . . . . . . . . . . . . . . . . 106
     19.13. STREAM_DATA_BLOCKED Frame  . . . . . . . . . . . . . . . 107
     19.14. STREAMS_BLOCKED Frames . . . . . . . . . . . . . . . . . 107
     19.15. NEW_CONNECTION_ID Frame  . . . . . . . . . . . . . . . . 108
     19.16. RETIRE_CONNECTION_ID Frame . . . . . . . . . . . . . . . 109
     19.17. PATH_CHALLENGE Frame . . . . . . . . . . . . . . . . . . 110
     19.18. PATH_RESPONSE Frame  . . . . . . . . . . . . . . . . . . 110
     19.19. CONNECTION_CLOSE Frames  . . . . . . . . . . . . . . . . 111



Iyengar & Thomson         Expires June 21, 2019                 [Page 4]

Internet-Draft           QUIC Transport Protocol           December 2018


     19.20. Extension Frames . . . . . . . . . . . . . . . . . . . . 112
   20. Transport Error Codes . . . . . . . . . . . . . . . . . . . . 112
     20.1.  Application Protocol Error Codes . . . . . . . . . . . . 113
   21. Security Considerations . . . . . . . . . . . . . . . . . . . 114
     21.1.  Handshake Denial of Service  . . . . . . . . . . . . . . 114
     21.2.  Amplification Attack . . . . . . . . . . . . . . . . . . 115
     21.3.  Optimistic ACK Attack  . . . . . . . . . . . . . . . . . 115
     21.4.  Slowloris Attacks  . . . . . . . . . . . . . . . . . . . 115
     21.5.  Stream Fragmentation and Reassembly Attacks  . . . . . . 116
     21.6.  Stream Commitment Attack . . . . . . . . . . . . . . . . 116
     21.7.  Explicit Congestion Notification Attacks . . . . . . . . 117
     21.8.  Stateless Reset Oracle . . . . . . . . . . . . . . . . . 117
   22. IANA Considerations . . . . . . . . . . . . . . . . . . . . . 117
     22.1.  QUIC Transport Parameter Registry  . . . . . . . . . . . 117
     22.2.  QUIC Frame Type Registry . . . . . . . . . . . . . . . . 119
     22.3.  QUIC Transport Error Codes Registry  . . . . . . . . . . 120
   23. References  . . . . . . . . . . . . . . . . . . . . . . . . . 123
     23.1.  Normative References . . . . . . . . . . . . . . . . . . 123
     23.2.  Informative References . . . . . . . . . . . . . . . . . 124
   Appendix A.  Sample Packet Number Decoding Algorithm  . . . . . . 126
   Appendix B.  Change Log . . . . . . . . . . . . . . . . . . . . . 126
     B.1.  Since draft-ietf-quic-transport-16  . . . . . . . . . . . 126
     B.2.  Since draft-ietf-quic-transport-15  . . . . . . . . . . . 128
     B.3.  Since draft-ietf-quic-transport-14  . . . . . . . . . . . 128
     B.4.  Since draft-ietf-quic-transport-13  . . . . . . . . . . . 128
     B.5.  Since draft-ietf-quic-transport-12  . . . . . . . . . . . 129
     B.6.  Since draft-ietf-quic-transport-11  . . . . . . . . . . . 130
     B.7.  Since draft-ietf-quic-transport-10  . . . . . . . . . . . 130
     B.8.  Since draft-ietf-quic-transport-09  . . . . . . . . . . . 131
     B.9.  Since draft-ietf-quic-transport-08  . . . . . . . . . . . 131
     B.10. Since draft-ietf-quic-transport-07  . . . . . . . . . . . 132
     B.11. Since draft-ietf-quic-transport-06  . . . . . . . . . . . 133
     B.12. Since draft-ietf-quic-transport-05  . . . . . . . . . . . 133
     B.13. Since draft-ietf-quic-transport-04  . . . . . . . . . . . 133
     B.14. Since draft-ietf-quic-transport-03  . . . . . . . . . . . 134
     B.15. Since draft-ietf-quic-transport-02  . . . . . . . . . . . 134
     B.16. Since draft-ietf-quic-transport-01  . . . . . . . . . . . 135
     B.17. Since draft-ietf-quic-transport-00  . . . . . . . . . . . 137
     B.18. Since draft-hamilton-quic-transport-protocol-01 . . . . . 137
   Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . . 138
   Contributors  . . . . . . . . . . . . . . . . . . . . . . . . . . 138
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . . 138

1.  Introduction

   QUIC is a multiplexed and secure general-purpose transport protocol
   that provides:




Iyengar & Thomson         Expires June 21, 2019                 [Page 5]

Internet-Draft           QUIC Transport Protocol           December 2018


   o  Stream multiplexing

   o  Stream and connection-level flow control

   o  Low-latency connection establishment

   o  Connection migration and resilience to NAT rebinding

   o  Authenticated and encrypted header and payload

   QUIC uses UDP as a substrate to avoid requiring changes to legacy
   client operating systems and middleboxes.  QUIC authenticates all of
   its headers and encrypts most of the data it exchanges, including its
   signaling, to avoid incurring a dependency on middleboxes.

1.1.  Document Structure

   This document describes the core QUIC protocol and is structured as
   follows.

   o  Streams are the basic service abstraction that QUIC provides.

      *  Section 2 describes core concepts related to streams,

      *  Section 3 provides a reference model for stream states, and

      *  Section 4 outlines the operation of flow control.

   o  Connections are the context in which QUIC endpoints communicate.

      *  Section 5 describes core concepts related to connections,

      *  Section 6 describes version negotiation,

      *  Section 7 details the process for establishing connections,

      *  Section 8 specifies critical denial of service mitigation
         mechanisms,

      *  Section 9 describes how endpoints migrate a connection to a new
         network path,

      *  Section 10 lists the options for terminating an open
         connection, and

      *  Section 11 provides general guidance for error handling.

   o  Packets and frames are the basic unit used by QUIC to communicate.



Iyengar & Thomson         Expires June 21, 2019                 [Page 6]

Internet-Draft           QUIC Transport Protocol           December 2018


      *  Section 12 describes concepts related to packets and frames,

      *  Section 13 defines models for the transmission, retransmission,
         and acknowledgement of data, and

      *  Section 14 specifies rules for managing the size of packets.

   o  Finally, encoding details of QUIC protocol elements are described
      in:

      *  Section 15 (Versions),

      *  Section 16 (Integer Encoding),

      *  Section 17 (Packet Headers),

      *  Section 18 (Transport Parameters),

      *  Section 19 (Frames), and

      *  Section 20 (Errors).

   Accompanying documents describe QUIC's loss detection and congestion
   control [QUIC-RECOVERY], and the use of TLS for key negotiation
   [QUIC-TLS].

   This document defines QUIC version 1, which conforms to the protocol
   invariants in [QUIC-INVARIANTS].

1.2.  Terms and Definitions

   The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in BCP
   14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

   Commonly used terms in the document are described below.

   QUIC:  The transport protocol described by this document.  QUIC is a
      name, not an acronym.

   QUIC packet:  The smallest unit of QUIC that can be encapsulated in a
      UDP datagram.  Multiple QUIC packets can be encapsulated in a
      single UDP datagram.






Iyengar & Thomson         Expires June 21, 2019                 [Page 7]

Internet-Draft           QUIC Transport Protocol           December 2018


   Endpoint:  An entity that can participate in a QUIC connection by
      generating, receiving, and processing QUIC packets.  There are
      only two types of endpoint in QUIC: client and server.

   Client:  The endpoint initiating a QUIC connection.

   Server:  The endpoint accepting incoming QUIC connections.

   Connection ID:  An opaque identifier that is used to identify a QUIC
      connection at an endpoint.  Each endpoint sets a value for its
      peer to include in packets sent towards the endpoint.

   Stream:  A unidirectional or bidirectional channel of ordered bytes
      within a QUIC connection.  A QUIC connection can carry multiple
      simultaneous streams.

   Application:  An entity that uses QUIC to send and receive data.

1.3.  Notational Conventions

   Packet and frame diagrams in this document use the format described
   in Section 3.1 of [RFC2360], with the following additional
   conventions:

   [x]:  Indicates that x is optional

   x (A):  Indicates that x is A bits long

   x (A/B/C) ...:  Indicates that x is one of A, B, or C bits long

   x (i) ...:  Indicates that x uses the variable-length encoding in
      Section 16

   x (*) ...:  Indicates that x is variable-length

2.  Streams

   Streams in QUIC provide a lightweight, ordered byte-stream
   abstraction to an application.  An alternative view of QUIC streams
   is as an elastic "message" abstraction.

   Streams can be created by sending data.  Other processes associated
   with stream management - ending, cancelling, and managing flow
   control - are all designed to impose minimal overheads.  For
   instance, a single STREAM frame (Section 19.8) can open, carry data
   for, and close a stream.  Streams can also be long-lived and can last
   the entire duration of a connection.




Iyengar & Thomson         Expires June 21, 2019                 [Page 8]

Internet-Draft           QUIC Transport Protocol           December 2018


   Streams can be created by either endpoint, can concurrently send data
   interleaved with other streams, and can be cancelled.  Any stream can
   be initiated by either endpoint.  QUIC does not provide any means of
   ensuring ordering between bytes on different streams.

   QUIC allows for an arbitrary number of streams to operate
   concurrently and for an arbitrary amount of data to be sent on any
   stream, subject to flow control constraints (see Section 4) and
   stream limits.

2.1.  Stream Types and Identifiers

   Streams can be unidirectional or bidirectional.  Unidirectional
   streams carry data in one direction: from the initiator of the stream
   to its peer.  Bidirectional streams allow for data to be sent in both
   directions.

   Streams are identified within a connection by a numeric value,
   referred to as the stream ID.  Stream IDs are unique to a stream.  A
   QUIC endpoint MUST NOT reuse a stream ID within a connection.  Stream
   IDs are encoded as variable-length integers (see Section 16).

   The least significant bit (0x1) of the stream ID identifies the
   initiator of the stream.  Client-initiated streams have even-numbered
   stream IDs (with the bit set to 0), and server-initiated streams have
   odd-numbered stream IDs (with the bit set to 1).

   The second least significant bit (0x2) of the stream ID distinguishes
   between bidirectional streams (with the bit set to 0) and
   unidirectional streams (with the bit set to 1).

   The least significant two bits from a stream ID therefore identify a
   stream as one of four types, as summarized in Table 1.

                +------+----------------------------------+
                | Bits | Stream Type                      |
                +------+----------------------------------+
                | 0x0  | Client-Initiated, Bidirectional  |
                |      |                                  |
                | 0x1  | Server-Initiated, Bidirectional  |
                |      |                                  |
                | 0x2  | Client-Initiated, Unidirectional |
                |      |                                  |
                | 0x3  | Server-Initiated, Unidirectional |
                +------+----------------------------------+

                         Table 1: Stream ID Types




Iyengar & Thomson         Expires June 21, 2019                 [Page 9]

Internet-Draft           QUIC Transport Protocol           December 2018


   Within each type, streams are created with numerically increasing
   stream IDs.  A stream ID that is used out of order results in all
   streams of that type with lower-numbered stream IDs also being
   opened.

   The first bidirectional stream opened by the client has a stream ID
   of 0.

2.2.  Sending and Receiving Data

   STREAM frames (Section 19.8) encapsulate data sent by an application.
   An endpoint uses the Stream ID and Offset fields in STREAM frames to
   place data in order.

   Endpoints MUST be able to deliver stream data to an application as an
   ordered byte-stream.  Delivering an ordered byte-stream requires that
   an endpoint buffer any data that is received out of order, up to the
   advertised flow control limit.

   QUIC makes no specific allowances for delivery of stream data out of
   order.  However, implementations MAY choose to offer the ability to
   deliver data out of order to a receiving application.

   An endpoint could receive data for a stream at the same stream offset
   multiple times.  Data that has already been received can be
   discarded.  The data at a given offset MUST NOT change if it is sent
   multiple times; an endpoint MAY treat receipt of different data at
   the same offset within a stream as a connection error of type
   PROTOCOL_VIOLATION.

   Streams are an ordered byte-stream abstraction with no other
   structure that is visible to QUIC.  STREAM frame boundaries are not
   expected to be preserved when data is transmitted, when data is
   retransmitted after packet loss, or when data is delivered to the
   application at a receiver.

   An endpoint MUST NOT send data on any stream without ensuring that it
   is within the flow control limits set by its peer.  Flow control is
   described in detail in Section 4.

2.3.  Stream Prioritization

   Stream multiplexing can have a significant effect on application
   performance if resources allocated to streams are correctly
   prioritized.






Iyengar & Thomson         Expires June 21, 2019                [Page 10]

Internet-Draft           QUIC Transport Protocol           December 2018


   QUIC does not provide frames for exchanging prioritization
   information.  Instead it relies on receiving priority information
   from the application that uses QUIC.

   A QUIC implementation SHOULD provide ways in which an application can
   indicate the relative priority of streams.  When deciding which
   streams to dedicate resources to, the implementation SHOULD use the
   information provided by the application.

3.  Stream States

   This section describes streams in terms of their send or receive
   components.  Two state machines are described: one for the streams on
   which an endpoint transmits data (Section 3.1), and another for
   streams on which an endpoint receives data (Section 3.2).

   Unidirectional streams use the applicable state machine directly.
   Bidirectional streams use both state machines.  For the most part,
   the use of these state machines is the same whether the stream is
   unidirectional or bidirectional.  The conditions for opening a stream
   are slightly more complex for a bidirectional stream because the
   opening of either send or receive sides causes the stream to open in
   both directions.

   An endpoint MUST open streams of the same type in increasing order of
   stream ID.

   Note:  These states are largely informative.  This document uses
      stream states to describe rules for when and how different types
      of frames can be sent and the reactions that are expected when
      different types of frames are received.  Though these state
      machines are intended to be useful in implementing QUIC, these
      states aren't intended to constrain implementations.  An
      implementation can define a different state machine as long as its
      behavior is consistent with an implementation that implements
      these states.

3.1.  Send Stream States

   Figure 1 shows the states for the part of a stream that sends data to
   a peer.










Iyengar & Thomson         Expires June 21, 2019                [Page 11]

Internet-Draft           QUIC Transport Protocol           December 2018


          o
          | Create Stream (Sending)
          | Peer Creates Bidirectional Stream
          v
      +-------+
      | Ready | Send RESET_STREAM
      |       |-----------------------.
      +-------+                       |
          |                           |
          | Send STREAM /             |
          |      STREAM_DATA_BLOCKED  |
          |                           |
          | Peer Creates              |
          |      Bidirectional Stream |
          v                           |
      +-------+                       |
      | Send  | Send RESET_STREAM     |
      |       |---------------------->|
      +-------+                       |
          |                           |
          | Send STREAM + FIN         |
          v                           v
      +-------+                   +-------+
      | Data  | Send RESET_STREAM | Reset |
      | Sent  |------------------>| Sent  |
      +-------+                   +-------+
          |                           |
          | Recv All ACKs             | Recv ACK
          v                           v
      +-------+                   +-------+
      | Data  |                   | Reset |
      | Recvd |                   | Recvd |
      +-------+                   +-------+

                     Figure 1: States for Send Streams

   The sending part of stream that the endpoint initiates (types 0 and 2
   for clients, 1 and 3 for servers) is opened by the application.  The
   "Ready" state represents a newly created stream that is able to
   accept data from the application.  Stream data might be buffered in
   this state in preparation for sending.

   Sending the first STREAM or STREAM_DATA_BLOCKED frame causes a send
   stream to enter the "Send" state.  An implementation might choose to
   defer allocating a stream ID to a send stream until it sends the
   first frame and enters this state, which can allow for better stream
   prioritization.




Iyengar & Thomson         Expires June 21, 2019                [Page 12]

Internet-Draft           QUIC Transport Protocol           December 2018


   The sending part of a bidirectional stream initiated by a peer (type
   0 for a server, type 1 for a client) enters the "Ready" state then
   immediately transitions to the "Send" state if the receiving part
   enters the "Recv" state (Section 3.2).

   In the "Send" state, an endpoint transmits - and retransmits as
   necessary - stream data in STREAM frames.  The endpoint respects the
   flow control limits set by its peer, and continues to accept and
   process MAX_STREAM_DATA frames.  An endpoint in the "Send" state
   generates STREAM_DATA_BLOCKED frames if it is blocked from sending by
   stream or connection flow control limits Section 4.1.

   After the application indicates that all stream data has been sent
   and a STREAM frame containing the FIN bit is sent, the send stream
   enters the "Data Sent" state.  From this state, the endpoint only
   retransmits stream data as necessary.  The endpoint does not need to
   check flow control limits or send STREAM_DATA_BLOCKED frames for a
   send stream in this state.  MAX_STREAM_DATA frames might be received
   until the peer receives the final stream offset.  The endpoint can
   safely ignore any MAX_STREAM_DATA frames it receives from its peer
   for a stream in this state.

   Once all stream data has been successfully acknowledged, the send
   stream enters the "Data Recvd" state, which is a terminal state.

   From any of the "Ready", "Send", or "Data Sent" states, an
   application can signal that it wishes to abandon transmission of
   stream data.  Alternatively, an endpoint might receive a STOP_SENDING
   frame from its peer.  In either case, the endpoint sends a
   RESET_STREAM frame, which causes the stream to enter the "Reset Sent"
   state.

   An endpoint MAY send a RESET_STREAM as the first frame on a send
   stream; this causes the send stream to open and then immediately
   transition to the "Reset Sent" state.

   Once a packet containing a RESET_STREAM has been acknowledged, the
   send stream enters the "Reset Recvd" state, which is a terminal
   state.

3.2.  Receive Stream States

   Figure 2 shows the states for the part of a stream that receives data
   from a peer.  The states for a receive stream mirror only some of the
   states of the send stream at the peer.  A receive stream does not
   track states on the send stream that cannot be observed, such as the
   "Ready" state.  Instead, receive streams track the delivery of data
   to the application, some of which cannot be observed by the sender.



Iyengar & Thomson         Expires June 21, 2019                [Page 13]

Internet-Draft           QUIC Transport Protocol           December 2018


          o
          | Recv STREAM / STREAM_DATA_BLOCKED / RESET_STREAM
          | Create Bidirectional Stream (Sending)
          | Recv MAX_STREAM_DATA / STOP_SENDING (Bidirectional)
          | Create Higher-Numbered Stream
          v
      +-------+
      | Recv  | Recv RESET_STREAM
      |       |-----------------------.
      +-------+                       |
          |                           |
          | Recv STREAM + FIN         |
          v                           |
      +-------+                       |
      | Size  | Recv RESET_STREAM     |
      | Known |---------------------->|
      +-------+                       |
          |                           |
          | Recv All Data             |
          v                           v
      +-------+ Recv RESET_STREAM +-------+
      | Data  |--- (optional) --->| Reset |
      | Recvd |  Recv All Data    | Recvd |
      +-------+<-- (optional) ----+-------+
          |                           |
          | App Read All Data         | App Read RST
          v                           v
      +-------+                   +-------+
      | Data  |                   | Reset |
      | Read  |                   | Read  |
      +-------+                   +-------+

                   Figure 2: States for Receive Streams

   The receiving part of a stream initiated by a peer (types 1 and 3 for
   a client, or 0 and 2 for a server) is created when the first STREAM,
   STREAM_DATA_BLOCKED, or RESET_STREAM is received for that stream.
   For bidirectional streams initiated by a peer, receipt of a
   MAX_STREAM_DATA or STOP_SENDING frame for the sending part of the
   stream also creates the receiving part.  The initial state for a
   receive stream is "Recv".

   The receive stream enters the "Recv" state when the sending part of a
   bidirectional stream initiated by the endpoint (type 0 for a client,
   type 1 for a server) enters the "Ready" state.

   An endpoint opens a bidirectional stream when a MAX_STREAM_DATA or
   STOP_SENDING frame is received from the peer for that stream.



Iyengar & Thomson         Expires June 21, 2019                [Page 14]

Internet-Draft           QUIC Transport Protocol           December 2018


   Receiving a MAX_STREAM_DATA frame for an unopened stream indicates
   that the remote peer has opened the stream and is providing flow
   control credit.  Receiving a STOP_SENDING frame for an unopened
   stream indicates that the remote peer no longer wishes to receive
   data on this stream.  Either frame might arrive before a STREAM or
   STREAM_DATA_BLOCKED frame if packets are lost or reordered.

   Before creating a stream, all streams of the same type with lower-
   numbered stream IDs MUST be created.  This ensures that the creation
   order for streams is consistent on both endpoints.

   In the "Recv" state, the endpoint receives STREAM and
   STREAM_DATA_BLOCKED frames.  Incoming data is buffered and can be
   reassembled into the correct order for delivery to the application.
   As data is consumed by the application and buffer space becomes
   available, the endpoint sends MAX_STREAM_DATA frames to allow the
   peer to send more data.

   When a STREAM frame with a FIN bit is received, the final offset is
   known (see Section 4.4).  The receive stream enters the "Size Known"
   state.  In this state, the endpoint no longer needs to send
   MAX_STREAM_DATA frames, it only receives any retransmissions of
   stream data.

   Once all data for the stream has been received, the receive stream
   enters the "Data Recvd" state.  This might happen as a result of
   receiving the same STREAM frame that causes the transition to "Size
   Known".  In this state, the endpoint has all stream data.  Any STREAM
   or STREAM_DATA_BLOCKED frames it receives for the stream can be
   discarded.

   The "Data Recvd" state persists until stream data has been delivered
   to the application.  Once stream data has been delivered, the stream
   enters the "Data Read" state, which is a terminal state.

   Receiving a RESET_STREAM frame in the "Recv" or "Size Known" states
   causes the stream to enter the "Reset Recvd" state.  This might cause
   the delivery of stream data to the application to be interrupted.

   It is possible that all stream data is received when a RESET_STREAM
   is received (that is, from the "Data Recvd" state).  Similarly, it is
   possible for remaining stream data to arrive after receiving a
   RESET_STREAM frame (the "Reset Recvd" state).  An implementation is
   free to manage this situation as it chooses.  Sending RESET_STREAM
   means that an endpoint cannot guarantee delivery of stream data;
   however there is no requirement that stream data not be delivered if
   a RESET_STREAM is received.  An implementation MAY interrupt delivery
   of stream data, discard any data that was not consumed, and signal



Iyengar & Thomson         Expires June 21, 2019                [Page 15]

Internet-Draft           QUIC Transport Protocol           December 2018


   the receipt of the RESET_STREAM immediately.  Alternatively, the
   RESET_STREAM signal might be suppressed or withheld if stream data is
   completely received and is buffered to be read by the application.
   In the latter case, the receive stream transitions from "Reset Recvd"
   to "Data Recvd".

   Once the application has been delivered the signal indicating that
   the receive stream was reset, the receive stream transitions to the
   "Reset Read" state, which is a terminal state.

